= Метод =
Для объявления метода используется запись типа, к которому принадлежит метод, перед его именем:
{{{go
func (p Point) Distance(q Point) float64 {
	return math.Hypot(q.X - p.X, q.Y - p.Y)
}
}}}

Методы могут быть объявлены для всех типов, кроме указателей и интерфейсов.

При вызове метода, вызываемый объект копируется как и любой аргумент, при этом метод не может изменить его состояния. Чтобы этого избежать, параметр объекта необходимо передать в виде указателя:
{{{go
func (p *Point) Distance(q Point) float64 {
	return math.Hypot(q.X - p.X, q.Y - p.Y)
}
}}}

По соглашению все методы типа должны быть либо копирующими вызываемый объект, либо изменяющими его состояние.

= Наследование методов =
Тип наследует методы базового:
{{{go
type Values map[string][]string

func (v Values) Add(key string, value string) {
	v[key] = append(v[key], value)
}

v := Values{"lang": {"en"}} // Непосредственное объявление
v.Add("lang", "ru")
fmt.Println(v["lang"]) // Непосредственный доступ
}}}

= Значения-методы =
Метод может быть передан в виде значения, сохраняя связь с объектом:
{{{go
type Rocket struct{...}

func (r *Rocket) Launch(){
	...
}

r := new(Rocket)
...

time.AfterFunc(10 * time.Second, r.Launch) // Launch будет вызван в контексте r
}}}

= Выражения-методы =
Методы, передаваемый в виде значения из типа, представляет собой обычную функцию, принимающую в качестве первого аргумента контекст вызова:
{{{go
type Pos struct {
	x int
	y int
}

func (p Pos) plus(x, y int) Pos {
	return Pos{p.x + x, p.y + y}
}

p := Pos{1, 1}
plus := Pos.plus // Выражение-метод

fmt.Println(p.plus(1, 0)) // 2, 1
fmt.Println(plus(p, 1, 0)) // 2, 1
}}}
