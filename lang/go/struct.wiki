= Массивы =
Массивы представляют множества однотипных данных неизменяемой длины.

Для объявления массива используется запись `var <name> [<size>]<type>`. Инициализировать массив можно с помощью литерала `[<size>]<type>{[index]: <value>, ...}` (вместо `size` можно использовать `...`, при этом размер массива будет расчитываться на основании числа его значений). Доступ к элементам массива осуществляется командой `<name>[<index>]`. Индексация массива начинается с нуля.

{{{go
var arr [3]int = [3]int{1, 2, 3}
// или
var arr [3]int = [...]int{1, 2, 3}
// или
arr := [...]int{1, 2, 3}

fmt.Println(arr[0])
}}}

{{{go
var arr [2][1]int = [2][1]int{{1}, {2}}
}}}

{{{go
type Currency int

const (
	USD Currency = iota
	EUR
	GBP
)

currencySymbol := [...]string{USD: "$", EUR: "€", GBP: "£"}

for i, v := range currencySymbol {
	fmt.Println(i, v)
}
}}}

Функция `len(array) int` позволяет определить длину массива.

К массивам можно применять операторы сравнения, если они объявлены для базового типа:
{{{go
a := [...]int{1, 2}
b := [...]int{1, 2}

fmt.Println(a == b) // true
}}}

Массивы передаются по значению. Для передачи их по ссылке необходимо сделать это явно:
{{{go
func zero(arr *[3]int) {
	*arr = [3]int{}
}

zero(&arr)
}}}

= Срезы =
Срезы это части массивов, имеющие изменяемую длину. Он включает указатель на исходный массив, свою длину (`len`) и емкость (`cap`).

Для объявления среза используется запись `var <name> []<type>`. Срез может быть инициализирован с помощью команды `<array|slice>[[start]:[end]]`, результирующий срез будет включать элементы от `start` до `end - 1`. Если `start` опущен, используется значение 0, если опущен `end`, используется значение `len(array)`. Так же срез может быть инициализирован с помощью литерала `[]<type>{[index]: <value>, ...}`, при этом будет создан массив необходимой длины и указатель на него в виде среза.

Попытка получения среза, выходящего за пределы исходного множества приведет к ошибке. Если же `end < cap(array)`, то срез будет расширен:
{{{go
months := []string{"Январь", "Февраль", ..., "Декабрь"}
summer := months[5:8]
summerAndAutumn := summer[:6]

fmt.Print(summer) // Июнь Июль Август
fmt.Print(summerAndAutumn) // Июнь Июль Август Сентябрь Октябрь Ноябрь
}}}

Функция `make([]<type>, [len], [cap])` позволяет создать срез указанной длины и указанной емкости. Она создает массив указанной длины и возвращает его срез так, чтобы учесть заданную емкость.

{{{go
slice := make([]int, 2, 5)
slice = slice[:5] // Расширение среза до длины массива

fmt.Print(slice) // 0 0 0 0 0
}}}

Функция `len(slice) int` возвращает длину среза, а функция `cap(slice) int` количество элементов от начала среза, до конца массиива, из которого он был срезан.

{{{go
months := [...]string{"Январь", "Февраль", ..., "Декабрь"}
summer := months[5:8]

fmt.Print(summer) // Июнь Июль Август
fmt.Print(len(summer)) // 3
fmt.Print(cap(summer)) // 7
}}}

Функции:
* `append(slice, value, ...) slice` - добавляет новый элемент в конец среза (`len(slice) + 1`), расширяя его при необходимости и возвращая результирующий срез (исходный срез не изменяется)
* `copy(toSlice, fromSlice) int` - копирует элементы из среза `fromSlice` в срез `toSlice` и возвращает количество реально скопированных элементов (меньшую из длин срезов)

= Словари =
Словари представляют ссылку на хеш-таблицу, ключами которой могут быть любые сравниваемые данные, а значениями любые данные вообще.

Для объявления словаря используется запись `map[<k-type>]<v-type>{}`. Инициализировать словарь можно с помощью литерала `map[<k-type>]<v-type>{"<key>": <value>, ...}`. Не инициализированный словарь указывает на `nil`. Доступ к элементам словаря осуществляется с помощью команды `<map>[<key>]`. При запросе элемента, не инициализированного в словаре, возвращается нулевое представление его типа и флаг, определяющий наличие этого элемента в словаре.

{{{go
m := map[string]int{"foo": 0}
m["bar"]++

fmt.Print(m) // {foo: 0, bar: 1}

if _, ok := m["baz"]; !ok {
	// ...
}
}}}

{{{go
m := map[string][]string{"foo": {"bar", "baz"}}
}}}

{{{go
m := map[string]string{"foo": "bar"}
if v, ok := m["foo"]; ok {
	fmt.Println(v)
}
}}}

Функция `len(map) int` возвращает число инициализированных элементов словаря.

Пример перебора отсортированного словаря:
{{{go
m := map[string]int{"foo": 1, "bar": 2}
names := make([]string, 0, len(m))
for name := range m {
	names = append(names, name)
}
sort.Strings(names)
for _, name := range names {
	fmt.Println(name, m[name])
}
}}}

Функции:
* `delete(map, key)` - позволяет удалить элемент словаря по ключу.

Пример многомерного словаря:
{{{go
package main

import (
	"fmt"
)

var graph = make(map[string]map[string]bool)

func addEdge(from, to string) {
	edges := graph[from]
	if edges == nil {
		edges = make(map[string]bool)
		graph[from] = edges
	}
	edges[to] = true
}

func hasEdge(from, to string) bool {
	return graph[from][to]
}

func main() {
	addEdge("foo", "bar")
	fmt.Print(hasEdge("foo", "bar")) // true
	fmt.Print(hasEdge("foo", "baz")) // false
}
}}}

= Структуры =
Структуры это агрегация нуля или более именованных значений произвольных типов.

Для объявления структуры используется запись:
{{{go
type <name> struct {
	<field> <type>
	...
}
}}}

Инициализировать структуру можно двумя способами:
* `<struct-name>{<value>, ...}` - инициализация полей структуры по порядку
* `<struct-name>{<field>: <value>, ...}` - инициализация полей структуры по именам

В структуру можно встроить другую структуру, используя запись:
{{{go
type <name> struct {
	<struct-name>
	...
}
}}}

Встраивание является синтаксическим сахаром над композицией и позволяет обращаться к вложеным структурам без указания полного пути:
{{{go
type Point struct {
	x int
	y int
}

type Circle struct {
	Point
	radius int
}

c := Circle{Point{1, 2}, 5}
// или
c := Circle{Point: Point{x: 1, y: 2}, radius: 5}

fmt.Print(c.x)
// или
fmt.Print(c.Point.x)
}}}

Структуру можно инициализировать в момент объявления:
{{{go
s := struct{x int; y int}{1, 2}
}}}
