= Объявление и вызов =
{{{go
func имя(аргументы) (возврат) {
	тело
}
}}}

Возвращаемые значения могут быть именованы, при этом создается локальные переменные функции с теми же именами. В таком случае `return` без параметров возвращает значения этих переменных согласно объявлению:
{{{go
func pow(num int) res int {
	res = num * num
	return // аналогично: return res
}
}}}
Обычно это используется для документирования возвращаемых значений.

Для создания функции с динамическим количеством аргументов используется запись `(<arg> ...<type>)`. Сам аргумент представляется в этом случае срезом данного типа:
{{{go
func sum(vars ...int) int {
	total := 0
	for _, v := range vars {
		total += v
	}
	return total
}
}}}

= Литерал функции =
Функции являются базовым типом данных, что позволяет хранить их в переменных:
{{{go
func square(n int) int {
	return n * n
}

func product(m, n int) int {
	return n * m
}

f := square
fmt.Print(f(2)) // 4
f = product // Ошибка: нельзя присвоить func(int, int) int переменной типа func(int) int
}}}

Возможность передавать функции как значения позволяет использовать их в качестве параметров других функций:
{{{go
fmt.Println(
	strings.Map(
		func (r rune) rune { // литерал функция
			return r + 1
		},
		"Hello",
	),
) // Ifmmp
}}}

Литерал функции имеют доступ к данным обрамляющих функций, что позволяет использовать замыкание:
{{{go
func squares() func() int {
	var x int
	
	return func() int {
		x++
		return x * x
	}
}

f := squares()
fmt.Println(f()) // 1
fmt.Println(f()) // 4
fmt.Println(f()) // 9
f = squares() // Использование новой локальной переменной
fmt.Println(f()) // 1
fmt.Println(f()) // 4
fmt.Println(f()) // 9
}}}

= Отложенный вызов =
Команда `defer` перед вызовом функции позволяет отложить ее вызов до завершения выполнения обрамляющей функции (после вызова `return`) или возникновения ошибки. Обычно она используется, для высвобождения полученных ресурсов:
{{{go
import ioutil

func ReadFile(filename string) ([]byte, error) {
	f, err = os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer f.Close() // Вызывается при завершении функции ReadFile
	return ReadAll(f)
}
}}}

= Обработка аварийных ситуаций =
Для завершения программы с ошибкой используется функция `panic(mixed)` принимающая любой аргумент в качестве описания произошедшей ошибки и завершающая программу.

Функция `recover() mixed` может использоваться в отложенных вызовах (`defer`) для получения информации о произошедшей ошибке. Если ошибки не было, то она возвращает `nil`:

{{{go
func Parser(in string) Tree {
	defer func() {
		if p := recover(); p != nil {
			// Произошла ошибка
			...
		}
		
		...
	}()
	
	...
}
}}}
