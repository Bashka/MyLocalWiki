= Типы данных =
== Логический тип ==
Тип `bool` представляет логические `true` и `false`.

Операции:
* `==` - равно
* `!=` - не равно
* `>` - больше
* `>=` - больше или равно
* `<` - меньше
* `<=` - меньше или равно
* `&&` - логическое И (используется сокращение)
* `||` - логическое ИЛИ (используется сокращение)
* `!` - логическое НЕ

**Важно**: логическому сравнению поддаются только данные одного типа, за исключением интерфейсов и ссылок, которые могут сравниваться с `nil`.

Логические операторы И и ИЛИ используют сокращение, что означает последовательное выполнение логического выражения 
слева на право до тех пор, пока ответ не будет однозначен, отбрасывая оставшуюся часть выражения:

{{{go
var s string = "hello"
// ...

if len(s) > 0 && s[0] == 'h' {
 // ...
}
}}}

== Числа ==
Типы `int`, `int8`, `int16`, `int32`, `int64` представляют целые числа соответствующей размерности бит.
Типы `uint`, `uint8`, `uint16`, `uint32`, `uint64` представляют целые, беззнаковые числа соответствующей размерности бит.
Тип `byte` является синонимом `uint8` и подчеркивает неформатированную природу данных.

* `int8` - от -128 до 127
* `int16` - от -32 768 до 32 767
* `int32` - от −2 147 483 648 до 2 147 483 647
* `uint8` - от 0 до 255
* `uint16` - от 0 до 65 535
* `uint32` - от 0 до 4 294 967 295

Типы `float32`, `float64` представляют дробные числа соответствующей размерности бит. Они могут быть записаны в десятичном 
формате с разделителем `.`, либо с использованием научной нотации `e`. Разряды до или после точки могут быть опущены:

{{{go
const e float32 = 2.71828
const x, y = .5, 5.
const planck float64 = 6.62606957e34
}}}

Типы `complex64`, `complex128` представляют комлексные числа с компонентами `float32` и `float64` соответственно. 
Функция `complex(real, imag)` создает комплексное число из действительной и мнимой части, а функции `real(complex)` 
и `imag(complex)` возвращают соответствующие части. Если за числовым литералом следует `i`, то он представляет 
комплексное число с заданной мнимой и нулевой действительной частями.

{{{go
const x complex64 = 1i

fmt.Println(x) // (0+1i)
}}}

Операции:
* `++` - инкремент (только постфиксная форма)
* `--` - декремент (только постфиксная форма)
* `+`, `+=` - сложение (с присваиванием)
* `-`, `-=` - вычитание (с присваиванием)
* `*`, `*=` - умножение (с присваиванием)
* `/`, `/=` - деление (с присваиванием)
* `%` - деление по модулю (только для типа `int`)

**Важно**: знак результата при делении по модулю аналогичен знаку делимого.

**Важно**: результат деления целых чисел округляется вниз.

== Строки ==
Тип `string` представляет строковые данные. Тип `byte` эквивалентен по размеру `int8` и представляет символ ASCII. 
Тип `rune` эквивалентен по размеру `int32` и представляет символ Unicode UTF-32.

Литералы строк могут записываться тремя способами:

* `''` - один символ
* `` - неформатированная последовательность байт (управляющие коды вставляются как есть)
* `""` - форматированная последовательность байт (управляющие коды вставляются явно)

{{{go
const x byte = 'x'
const y rune = 'ч'
}}}

{{{go
fmt.Println(`
	Hello
	world
`)
}}}

Для записи шестнадцатиричных и восьмиричных управляющих последовательностей, используются литералы `\x00` 
и `\000` соответственно. Литералы `\u0000` и `\U00000000` позволяют записать 16-разрядные и 32-разрядные 
управляющие последовательности:

{{{go
const s string = "\123 \x12 \u1234 \U0000754c"
fmt.Println(s)
}}}

Функция `len(string)` возвращает количество байт, занимаемых строкой.

Операции:
* `+`, `+=` - конкатенация (с присваиванием)
* `==`, `>`, `>=`, `<`, `<=`, `!=` - побайтовое сравнение
* `[i]` - получение конкретного байта
* `[i:j]` - получение среза

**Важно**: строки являются неизменяемым типом данных:

{{{go
s[0] = 'x' // Error: не допускается изменение строки
}}}

== Оъявление именованного типа ==
Команда `type <name> <type>` позволяет объявить именованный тип с теми же операциями, что и базовый.

{{{go
type Celsius float64 // градусы по цельсию
type Fahrenheit float64 // градусы по фаренгейту
}}}

== Приведение типов ==
Операция `<type>(<value>)` выполняет преобразование типа без изменения значения. Она допустима для типов, имеющих одинаковый базовый тип.

{{{go
type Celsius float64
type Fahrenheit float64

var c Celsius = 5.5
var f Fahrenheit = Fahrenheit(c) // Приведение типа Celsius к типу Fahrenheit
fmt.Println(c) // 5.5
fmt.Println(f) // 5.5
var s string = string(c) // error - разный базовый тип, приведение не возможно
}}}

Результатом выражения является тип, наиболее общего порядка:
{{{go
day := 24 * time.Hour // Типом day является time.Duration
fmt.Println(day.Seconds()) // 86400
}}}

= Переменные =
{{{go
package main

import "fmt"

func main() {
	var foo, bar string = "foo", "bar"
	
	foo = "foz"

	fmt.Println(foo)
	fmt.Println(bar)
}
}}}

Переменные объявляются директивой `var <names> <type>` и могут быть тут же инициализированы `= <values>`.

Группа переменных может быть объявлена в скобках:
{{{go
var (
	foo string = "foo"
	bar int = 5
)
}}}

Не инициализированные при объявлении переменные заполняются нулевым значением, для чисел это `0`, а для строк `""`.

Директива `:=` представляет сокращенную форму объявления и инициализации переменной, тип которой определяется автоматически исходя из инициализирующих значений:
{{{go
package main

import "fmt"

func main() {
	foo, bar := 1, 2

	fmt.Println(foo)
	fmt.Println(bar)
}
}}}

Функция `new(type) *type` используется для получения адреса памяти для заданного типа данных:
{{{go
var foo *int = new(int)
}}}

= Константы =
{{{go
package main

import "fmt"

func main() {
	const foo, bar string = "foo", "bar"
	
	foo = "foz" // error

	fmt.Println(foo)
	fmt.Println(bar)
}
}}}

Константы объявляются директивой `var <names> <type>` и должны быть тут же инициализированы `= <values>`.

Константа может быть инициализирована только строкой, числом или логическим значением.

Группа констант может быть объявлена в скобках:
{{{go
const (
	foo string = "foo"
	bar int = 5
)
}}}

= Указатели =
Для взятия адреса переменной, используется команда `&<var>`:
{{{go
foo := "foo"
bar := &foo
}}}

Для взятия значения по адресу, используется команда `*<var>`:
{{{go
foo := "foo"
bar := &foo

fmt.Println(*bar) // foo

*bar = "bar"
fmt.Println(foo) // bar
}}}

Функции могут получать и возвращать указатели:
{{{go
func incr(value *int) *int {
	*value++

	return value
}

func main() {
	value := 0

	incr(incr(&value))
	fmt.Println(value)
}
}}}

{{{go
func getVariable() *int {
	variable := 0

	return &variable
}

func main() {
	fmt.Println(getVariable() == getVariable())
}
}}}
